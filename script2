
var replaceFiles = [
        {   from:  new RegExp('^.*/resources/Vdom/_private/Synchronizer/resources/Debug0.js'),
            to: 'c:/fiddler/replace/Debug.js'
            // includes: new RegExp('Debug.js'),
            // excludes: new RegExp('Debug1.js')
        },
        {   from:  new RegExp('^.*/resources/(.*/)(.+)$','i'),
            to: 'c:/fiddler/replace/$1$2',
            includes: [ new RegExp('/Debug000.js') ],
            onReplace:  { hideRow: false, backcolor: '#17AF13', color: '#000', bold: true  }, // стили строки при успешной подмене файла
            onError:    { hideRow: false, backcolor: '#550000', color: '#000', bold: true  }  // стили строки при ошибках при подмене файла
        }
    ];

var cacheFiles = [
        {
            includes: [ new RegExp('\.ru/cdn/.*\\.js',''),
                        new RegExp('\.ru/cdn/.*\\.woff2','') ],
            to: 'g:/fiddler/cache_cdn/',
            onSaveToCache:   { hideRow: false, backcolor: '#F9A900', color: '#000', bold: true  }, // стили строки до загрузки из кэша
            onLoadFromCache: { hideRow: true,  backcolor: '#F5EB89', color: '#000', bold: false }  // стили строки при загрузке из кэша
        },
    
        {
            includes: [ new RegExp('\\.png$') ],
            to: 'g:/fiddler/cache_images/',
            onSaveToCache:   { hideRow: false, backcolor: '#F9F900', color: '#000', bold: true  }, // стили строки до загрузки из кэша
            onLoadFromCache: { hideRow: true,  backcolor: '#F5EB89', color: '#000', bold: false }  // стили строки при загрузке из кэша
        },

        {
            includes: [ new RegExp('/resources/Vdom/.*\\.(js|wml|css)'),
                        new RegExp('/resources/Controls/.*\\.(js|wml|css)'),
                        new RegExp('/resources/Browser/.*\\.js'),
                        new RegExp('/resources/Router/.*\\.(js|wml)'),
                        new RegExp('/resources/UI/.*\\.(js|wml)'),
                        new RegExp('/resources/WS\\.Core/.*'),
                        new RegExp('/resources/AuthFramework/.*'),
                        new RegExp('/resources/ParametersWebAPI/.*'),
                        new RegExp('/resources/EngineLanguage/.*'),
                        new RegExp('/resources/Env/.*\\.js'),
                        new RegExp('/resources/I18n/.*\\.js'),
                        new RegExp('/resources/View/.*\\.js'),
                        new RegExp('/resources/SBIS3\\.Plugin/.*\\.js'),
                        new RegExp('/resources/Types/.*\\.js') ],
            to: 'g:/fiddler/cache_other/',
            saveWithHeaders: true,
            onSaveToCache:   { hideRow: false, backcolor: '#F9F900', color: '#000', bold: true  }, // стили строки до загрузки из кэша
            onLoadFromCache: { hideRow: true,  backcolor: '#F5EB89', color: '#000', bold: false }  // стили строки при загрузке из кэша
        },

    ];

var collectFiles = [
        {   
            to: 'g:/fiddler/collectFiles/',  // куда сохранять файлы которые после будут собираться в один
            includes: [ new RegExp('/resources/.*\\.js\\?')  ],
            excludes: [ new RegExp('/resources/Guest/')  ],
            onSaveToCollect:   { hideRow: false, backcolor: '#F95500', color: '#000', bold: true  }, // стили строки до загрузки
            onLoadFromCollect: { hideRow: false, backcolor: '#A55589', color: '#000', bold: false }  // стили строки при загрузке
        },
    ];

// testOptions - проверяет каждую опцию из replaceFiles/collectFiles/cacheFiles
//               могут быть заданы параметры includes: RegExp[], excludes: RegExp[],
function checkOptions(opt: Object):Object {
    return opt;
}

// testFile - проверяет соответствует ли запрашиваемый файл в Session критериям в opt.includes/excludes
function testFile(opt: Object, oSession: Session):boolean {
    var url = oSession.fullUrl;
    var ok = false;
    var includes = opt.includes;
    if(includes && includes.length > 0) {
        for(var i = 0; i < includes.length; i++) {
            var re = includes[i];
            var b = re.test(url);
            if( b ) {
                ok = true;
                break;
            }
        }
        if(!ok) return false;
    }
    var excludes = opt.excludes;
    if(excludes && excludes.length > 0) {
        var excludes = opt.excludes;
        for(var i = 0; i < excludes.length; i++) {
            var re = excludes[i];
            var b = re.test(url);
            if( b ) return false;
        }
    }
    return true;
}

// set row style - проверяет соответствует ли запрашиваемый файл в Session критериям в opt.includes/excludes
function setRowStyle(opt: Object, oSession: Session):void {
    if(!opt) return;
    if(opt.hideRow) {
        oSession['ui-hide'] = true;
        return;
    }
    oSession["ui-color"] = opt.color;
    if(opt.bold) oSession["ui-bold"] = opt.bold;
    oSession["ui-backcolor"] = opt.backcolor;
}


import System;
import System.Windows.Forms;
import Fiddler;

var fileExists = System.IO.File.Exists;
var dirExists = System.IO.Directory.Exists;
var GetDirectoryName = System.IO.Path.GetDirectoryName;

function wlog(msg: String) {
    WriteToFile("C:/fiddler/log.txt",msg+"\n", 'a');
}

function WriteToFile(file: String, text: String, aORw: String) { // aORw=='a' || aORw=='w'  - a - append, w - write to file
    if( !CreatePathForFile(file) ) return 0;
    if( !aORw || aORw === 'a' ) return System.IO.File.AppendAllText(file,text);
    if( aORw === 'w' ) return System.IO.File.WriteAllText(file,text);
}

function CreatePathForFile(file: String) {
    return CreatePath( GetDirectoryName(file) );
}

function CreatePath(path: String) {
    if( !path ) return 0;
    if( !dirExists(path) ) {
        var basePath = GetDirectoryName(path);
        if( !dirExists(basePath) ) {
            var b = CreatePath(basePath);
            if( !b ) return 0;
        }
        return System.IO.Directory.CreateDirectory(path);
    }
    return 1;
}

// возвращает относительный путь к файлу из урл для сохранения (вместе с https_название_сайта/и/т/д)
//   extension:String - строка на которую будет заканчиваться файл если путь к нему заканчивается на /
function getFileSavePathFromUrl(oSession: Session,extension:String):String {
    var url = oSession.fullUrl;
    var file = url.replace(/[\?=\*].*$/,''); // удаляем все после ? или = или *
    file = file.replace(/(:\/\/|:)/g,'_'); // заменяем на _ все "://" или ":"
    file = file.replace(/\/+/g,'/');  // заменяем все двойные и более слеши на одинарный
    if(file.length > 200) file = file.substr(0,200); // путь к файлу должен быть не более 260 символов
    if(file.length > 0 && file[file.length-1] == '/') file += extension;
    return file;
}


class Handlers {
    // набор обработчиков для каждого типа
    static public var workers = new Array();
    static public var workersLoaded = 0;
    
    static function Main() {
        var i:int;
        var today: Date = new Date();
        FiddlerObject.StatusText = " CustomRules.js was loaded at: " + today;
        initWorkers();
    }

    static function initWorkers() {
        if( workersLoaded ) return;
        Handlers.workers = new Array();
        var workersLoaded = 0;
        var i;
        for(i = 0; i < replaceFiles.length; i++){
            Handlers.workers[workersLoaded] = new ReplaceFile(replaceFiles[i],i,workersLoaded++);
        }
        for(i = 0; i < collectFiles.length; i++){
            Handlers.workers[workersLoaded] = new CollectFile(collectFiles[i],i,workersLoaded++);
        }
        for(i = 0; i < cacheFiles.length; i++){
            Handlers.workers[workersLoaded] = new CacheFile(cacheFiles[i],i,workersLoaded++);
        }
        Handlers.workersLoaded = workersLoaded;
        alert('load workers: '+workersLoaded,'');
    }

    // The following snippet demonstrates a custom-bound column for the Web Sessions list.
    // See http://fiddler2.com/r/?fiddlercolumns for more info
    public static BindUIColumn("Method", 60)
    function FillMethodColumn(oS: Session): String {
        return oS.RequestMethod;
    }
    
    public static BindUIColumn("Time", 60)
    function FillTimeColumn(oS: Session): String {
        var d:double = (oS.Timers.ServerDoneResponse.Ticks - oS.Timers.ClientBeginRequest.Ticks)/10000;//(1000*1000*10);
        var n = d.toString().replace(/\..*$/,'');  // Math.Round(d,0)
        if( d > 24 * 60 * 60 *1000 ) n = '-';
        return n;
    }
    
    public static BindUIColumn("info", 200)
    function FillinfoColumn(oS: Session): String {
        var text = '';
        if( oS['_#info'] !== undefined ){
            if( oS["_#error"] == true ){
                text = 'ERROR';
                oS["ui-backcolor"] = "#aa5555";
                oS["ui-color"] = "#aaeeee";
                oS["ui-bold"] = true;
                text += oS["_#error"];
            }
            text += oS['_#info'];
        }
        return text;
    }        

    static function OnBeforeRequest(oSession: Session) {
        var workers = Handlers.workers;
        var workersLoaded = Handlers.workersLoaded;
        for(var i = 0; i < workersLoaded; i++){
            var w:Worker = workers[i];
            if( w.loadResponse(oSession) ) return;
        }       
    }

    static function OnDone(oSession: Session) {
        var workerN = oSession['_#onDoneWorkerN'];
        if( workerN !== undefined ){
            var w:Worker = Handlers.workers[workerN];
            w.onDoneFnc(oSession);
        }
    }
}

class Worker {
    protected var opt;
    
    function Worker(opt: Object, type:String, ruleN:int, workerN:int) {
        opt.type = type;
        opt.ruleN = ruleN;
        opt.workerN = workerN;
        opt.name = type + ' options' + ruleN;
        this.opt = checkOptions(opt);
    }
    
    public function loadResponse(oSession:Session):boolean {
        alert('какого хрена Worker',oSession);
        return false;
    }
    
    public function onDoneFnc(oSession:Session):boolean {
        return false;
    }
    
    public function setInfo(oSession:Session, text:String, isError:boolean):void {
        var opt = this.opt;
        oSession['_#info'] = '['+ opt.type +' rule ' + opt.ruleN + '] '+text;
        oSession['_#error'] = isError;
    }
        
    public function getInfo():String {
        var opt = this.opt;
        var text = '['+ opt.type +' rule ' + opt.ruleN + ']';
        return text;
    }
}

class ReplaceFile extends Worker {
    private var type;
    
    function ReplaceFile(opt: Object, ruleN:int, workerN:int) {
        super(opt, 'replace', ruleN, workerN);
        var to = this.opt.to
        if( /^[a-z]:(\\|\/)/i.test(to) ) {
            this.type = 'localfile';
        }else{
            alert('не верно задан параметр to',this.getInfo());
        }
    }
    
    public function loadResponse(oSession: Session):boolean {
        if( !testFile(this.opt, oSession) ) return false;
        var url = oSession.fullUrl;
        var to = this.opt.to
        var newUrl = url.replace( this.opt.from, to);
        if( newUrl === url ) return false;
        if( this.type == 'localfile' ) {
            var filePath = newUrl.replace(/\?.*$/,'');
            var b:boolean = oSession.LoadResponseFromFile(filePath);
            if( !b ){
                setRowStyle(this.opt.onError, oSession);
                this.setInfo(oSession,'err load from file: ' + filePath, true);
            }else{
                setRowStyle(this.opt.onReplace, oSession);
                this.setInfo(oSession, 'file: ' + filePath, false);
            }
        } else {
            setRowStyle(this.opt.onReplace, oSession);
            this.setInfo(oSession,'url: ' + newUrl, false);
        }
        return true;
    }
}

class CollectFile extends Worker  {
    private var filesLoaded = Object();
    private var filesLoadedArr = new Array();
    private var filesNeedLoad = Object();
    private var filesNeedLoadArr = new Array();
    private var oneFile:String = '';
    private var locked = false;

    function CollectFile(opt: Object, ruleN:int, workerN:int) {
        super(opt, 'collect', ruleN, workerN);
        var to = this.opt.to;
        if( !to || !/^[a-z]:(\\|\/)/i.test(to) ) {
            alert('не верно задан параметр to',this.getInfo());
        }
        this.oneFile = to + '/oneFileForAll';
        this.clearCollect();
        
        var dt:DateTime = System.IO.File.GetCreationTime(this.oneFile);       
        var t1 = dt.Ticks;
        var t2 = dt.Ticks - 1000*1000*10;
        alert(
            '\ndt: '+ t1 + 
            '\ndt: '+ t2 + 
            '\ndt: '+ new DateTime(t1) + 
            '\ndt: '+ new DateTime(t2) + 
            '','');
    }
    
    public function clearCollect() {
        this.filesLoaded = Object();
        this.filesLoaded.length = 0;
        WriteToFile(this.oneFile,'','w'); // очищаем файл куда будем все собирать
    }
    
    // updateCollect - собирает все файлы из filesNeedLoadArr в один this.oneFile
    public function updateCollect() {
        if( this.locked === true ) return; // если уже собираем файлы в один
        this.locked = true;
        if( !fileExists(this.oneFile) ) {
            this.clearCollect();
        }
        
        // собираем не чаще чем один раз в 20 сек
        var dt = System.IO.File.GetLastWriteTime(this.oneFile).Ticks + 1000*1000*10 * 20; // 1000*1000*10 - 1 секунда
        var needTimeout = DateTime.Now.Ticks;
        if( dt > needTimeout ){
            this.locked = false;
            return;
        }
        
        // alert('updateCollect',this.filesNeedLoadArr);
        alert('Collect files '+this.filesNeedLoadArr.length, this.filesNeedLoadArr.slice(0,10) );
        var buffer = '';
        var loaded = 0;
        for(var i=0; i < this.filesNeedLoadArr.length; i++ ) {
            var filePath = this.filesNeedLoadArr[i];
            var fullFilePath = this.opt.to + filePath;
            if( fileExists(fullFilePath) ) {
                buffer += System.IO.File.ReadAllText(fullFilePath, System.Text.Encoding.UTF8);
                loaded++;
                this.filesLoaded[filePath] = true; // ставим флаг что этот файл уже загружен в набор
                this.filesLoaded.length++;
                this.filesLoadedArr.push(filePath);
            }
        }
        if( loaded > 0 ) WriteToFile(this.oneFile, buffer,'a'); // дописываем в файл 
        alert('Collected files '+this.filesLoadedArr.length, this.filesLoadedArr.slice(0,10) );

        this.filesNeedLoad = Object();
        this.filesNeedLoadArr = new Array(); 
        this.locked = false;
    }
    
    public function loadResponse(oSession: Session):boolean {
        if( !testFile(this.opt, oSession) ) return false;
        
        var filePath = getFileSavePathFromUrl(oSession,'.collect');
        
        if( this.locked === false ) { // если сейчас не идет сборка файлов в один
            if( this.filesNeedLoadArr.length > 0 ) this.updateCollect(); // пробуем собрать

            if( this.filesLoaded[filePath] !== undefined ) { // если файл уже в наборе
                if( !fileExists(this.oneFile) ) {
                    this.clearCollect();
                }else{
                    setRowStyle(this.opt.onLoadFromCollect, oSession);
                    var len = this.filesLoaded.length;
                    this.setInfo(oSession, 'load from collect('+len+' files): '+this.oneFile, false);
                    oSession.LoadResponseFromFile(this.oneFile);
                    return true;
                }
            }
        
            if( this.filesNeedLoad[filePath] === undefined ) {
                this.filesNeedLoad[filePath] = true; // ставим флаг что файл планируется добавить в набор
                this.filesNeedLoadArr.push(filePath);
            }
        }
            
        setRowStyle(this.opt.onSaveToCollect, oSession);
        this.setInfo(oSession, 'wait for add collect from: '+ this.opt.to + filePath, false);
        
        filePath = this.opt.to + filePath;
        
        if( fileExists(filePath) ) { // если его уже сохранили для добавления
            oSession.LoadResponseFromFile(filePath); // можно его и вернуть а в след проходе он уже будет в общей куче
            return true;
        }
        
        oSession['_#collectpath'] = filePath;
        oSession['_#onDoneWorkerN'] = this.opt.workerN;
        return true;
    }
    
    public function onDoneFnc(oSession: Session):boolean {
        var filePath = oSession['_#collectpath'];
        if( fileExists(filePath) ) return true;        
        oSession.utilDecodeResponse();
        var oBody = System.Text.Encoding.UTF8.GetString(oSession.responseBodyBytes);
        oBody = '\n\n/**** file: '+ oSession.fullUrl + ' ****/\n' + oBody;
        return WriteToFile(filePath, oBody,'w');
    }

}

class CacheFile extends Worker {
    
    function CacheFile(opt: Object, ruleN:int, workerN:int) {
        super(opt, 'cache', ruleN, workerN);
    }
    
    public function loadResponse(oSession: Session):boolean {
        if( !testFile(this.opt, oSession) ) return false;
        var filePath = this.opt.to + getFileSavePathFromUrl(oSession,'.cache');
        if( fileExists(filePath) ) {
            var b = oSession.LoadResponseFromFile(filePath);
            if(b) {
                setRowStyle(this.opt.onLoadFromCache, oSession);
                this.setInfo(oSession, 'load: '+filePath, false);
                return true;
            }else{
                this.setInfo(oSession, 'cant load: '+filePath, true);
            }
        }else{
            setRowStyle(this.opt.onSaveToCache, oSession);
            this.setInfo(oSession, 'try save: '+filePath, false);
        }
        oSession['_#cachepath'] = filePath;
        oSession['_#onDoneWorkerN'] = this.opt.workerN;
        return true;
    }
    
    public function onDoneFnc(oSession: Session):boolean {
        var outFilePath = oSession['_#cachepath'];
        if( fileExists(outFilePath) ) return true;        
        oSession.utilDecodeResponse();
        if( this.opt.saveWithHeaders===true ){
            oSession.SaveResponse(outFilePath,false);
            return true;
        }
        var oBody = System.Text.Encoding.UTF8.GetString(oSession.responseBodyBytes);
        return WriteToFile(outFilePath,oBody,'w');
    }
}

function alert(msg,obj):void {
    if(obj && obj.name) msg += '\nname: '+obj.name;
    var dump:String = obj;
    if ( obj instanceof Array) dump = dumpArray(obj);
    FiddlerObject.alert(msg+'\n'+ dump);
}

function dumpArray(arr:Array):String {
    var s = '[';
    for(var i=0; i < arr.length; i++ ) {
        s += '\n  '+ String(arr[i]) +',';
    }
    if ( i > 0 ) s += '\n';
    return s + ']';
}

